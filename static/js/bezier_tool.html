<!DOCTYPE html>
<html>

<head>
    <style>
        body {
            font-family: sans-serif;
        }

        #canvas-container {
            position: relative;
            width: 600px;
            height: 400px;
            border: 1px solid #ccc;
            margin: 20px auto;
            background-color: #f9f9f9;
        }

        canvas {
            display: block;
        }

        .controls {
            text-align: center;
            margin-top: 10px;
        }

        .explanation {
            max-width: 600px;
            margin: 0 auto;
            font-size: 0.9em;
            color: #555;
        }
    </style>
</head>

<body>

    <div id="canvas-container">
        <canvas id="bezierCanvas" width="600" height="400"></canvas>
    </div>

    <div class="controls">
        <button onclick="resetPoints()">Reset Control Points</button>
    </div>

    <div class="explanation">
        <p><strong>Interactive Bézier Curve Demo:</strong> Drag the red control points to reshape the curve. The blue
            curve represents the learned scheduler function (e.g., &alpha;(t) or &sigma;(t)). The endpoints are fixed to
            ensure boundary conditions.</p>
    </div>

    <script>
        const canvas = document.getElementById('bezierCanvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;
        const padding = 50;

        // Initial Control Points (normalized 0-1)
        let points = [
            { x: 0, y: 0 },   // Start (Fixed)
            { x: 0.25, y: 0.2 },
            { x: 0.5, y: 0.8 },
            { x: 0.75, y: 0.5 },
            { x: 1, y: 1 }    // End (Fixed)
        ];

        let isDragging = false;
        let dragIndex = -1;

        function toScreen(p) {
            return {
                x: padding + p.x * (width - 2 * padding),
                y: height - padding - p.y * (height - 2 * padding) // Flip Y
            };
        }

        function toWorld(x, y) {
            return {
                x: (x - padding) / (width - 2 * padding),
                y: (height - padding - y) / (height - 2 * padding)
            };
        }

        function drawGrid() {
            ctx.strokeStyle = '#eee';
            ctx.lineWidth = 1;
            ctx.beginPath();
            // Vertical lines
            for (let i = 0; i <= 10; i++) {
                let x = padding + i * (width - 2 * padding) / 10;
                ctx.moveTo(x, padding);
                ctx.lineTo(x, height - padding);
            }
            // Horizontal lines
            for (let i = 0; i <= 10; i++) {
                let y = padding + i * (height - 2 * padding) / 10;
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
            }
            ctx.stroke();

            // Axes
            ctx.strokeStyle = '#aaa';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, height - padding); // Origin
            ctx.lineTo(width - padding, height - padding); // X axis
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(padding, padding); // Y axis
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.fillText('Time (s)', width / 2, height - 10);
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Value', 0, 0);
            ctx.restore();
        }

        function drawBezier() {
            ctx.clearRect(0, 0, width, height);
            drawGrid();

            const screenPoints = points.map(toScreen);

            // Draw Control Polygon
            ctx.strokeStyle = '#ccc';
            ctx.setLineDash([5, 5]);
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(screenPoints[0].x, screenPoints[0].y);
            for (let i = 1; i < screenPoints.length; i++) {
                ctx.lineTo(screenPoints[i].x, screenPoints[i].y);
            }
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw Bézier Curve
            ctx.strokeStyle = '#209cee'; // Bulma info color
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(screenPoints[0].x, screenPoints[0].y);

            // De Casteljau's algorithm or simple sampling for drawing
            for (let t = 0; t <= 1; t += 0.01) {
                const p = getBezierPoint(t, points);
                const sp = toScreen(p);
                ctx.lineTo(sp.x, sp.y);
            }
            ctx.stroke();

            // Draw Control Points
            screenPoints.forEach((p, i) => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 6, 0, 2 * Math.PI);
                if (i === 0 || i === points.length - 1) {
                    ctx.fillStyle = '#888'; // Fixed points
                } else {
                    ctx.fillStyle = '#ff3860'; // Draggable points (Bulma danger color)
                }
                ctx.fill();
                ctx.stroke();
            });
        }

        function getBezierPoint(t, controlPoints) {
            const n = controlPoints.length - 1;
            let x = 0;
            let y = 0;
            for (let i = 0; i <= n; i++) {
                const binom = factorial(n) / (factorial(i) * factorial(n - i));
                const bernstein = binom * Math.pow(1 - t, n - i) * Math.pow(t, i);
                x += controlPoints[i].x * bernstein;
                y += controlPoints[i].y * bernstein;
            }
            return { x, y };
        }

        function factorial(n) {
            if (n === 0) return 1;
            let res = 1;
            for (let i = 1; i <= n; i++) res *= i;
            return res;
        }

        function resetPoints() {
            points = [
                { x: 0, y: 0 },
                { x: 0.25, y: 0.2 },
                { x: 0.5, y: 0.8 },
                { x: 0.75, y: 0.5 },
                { x: 1, y: 1 }
            ];
            drawBezier();
        }

        // Interaction
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            points.forEach((p, i) => {
                if (i === 0 || i === points.length - 1) return; // Skip fixed points
                const sp = toScreen(p);
                const dist = Math.sqrt((x - sp.x) ** 2 + (y - sp.y) ** 2);
                if (dist < 10) {
                    isDragging = true;
                    dragIndex = i;
                }
            });
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging && dragIndex !== -1) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Constrain to canvas area (roughly)
                let wp = toWorld(x, y);
                wp.x = Math.max(0, Math.min(1, wp.x));
                wp.y = Math.max(0, Math.min(1, wp.y));

                // Optional: Constrain x to maintain order if we wanted strictly monotonic in time, 
                // but standard Bezier doesn't strictly require control points to be monotonic in x 
                // for the curve to be a function y=f(x) (though it helps). 
                // For this demo, we allow free movement to show flexibility, 
                // but in the paper, they enforce monotonicity.
                // Let's just allow free movement for visual effect.

                points[dragIndex] = wp;
                drawBezier();
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            dragIndex = -1;
        });

        drawBezier();
    </script>

</body>

</html>